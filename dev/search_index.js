var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = SymbolicCRN","category":"page"},{"location":"#SymbolicCRN","page":"Home","title":"SymbolicCRN","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for SymbolicCRN.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [SymbolicCRN]","category":"page"},{"location":"#SymbolicCRN.PolyPolyt","page":"Home","title":"SymbolicCRN.PolyPolyt","text":"struct PolyPolyt{T}\n\nA polynomial p, its Newton polytope Newtonpolyt (as Polymake big object, with the vertices computed) and the map vertices -> points vertex_point_map (vector storing the position of vertex in polynomial p).\n\nMethods to create a PolyPolyt:\n\nPolyPolyt(p::MPolyElem) # Requires computing the vertices of the Newton polytope.\nPolyPolyt(p::MPolyElem, vertices, ver_pt_map) # Loads vertices and ver-to-pt map.\nPolyPolyt(p::MPolyElem, name) # Loads them from files generated by save_polypolyt(name::String, pp)\n\n\n\n\n\n","category":"type"},{"location":"#SymbolicCRN.tpoly","page":"Home","title":"SymbolicCRN.tpoly","text":"Structure of a tpolynomial P. Vector p of coefficients of P, with v[1] != 0 (nonzero independent term) and integer mindeg indicating the smallest degree of P. mindeg can be negative, we have, with n = length(v)-1,\n\n     poly = t^(P.mindeg) * sum( P.p .* [1, t,..., t^n])\n\n\n\n\n\n","category":"type"},{"location":"#AbstractAlgebra.matrix-Tuple{Any, AbstractVector}","page":"Home","title":"AbstractAlgebra.matrix","text":"matrix(R, V)\n\n\nGiven a Julia vector V of entries, construct the corresponding AbstractAlgebra.jl one-column matrix over the given ring R, assuming all the entries can be coerced into R.\n\n\n\n\n\n","category":"method"},{"location":"#SymbolicCRN.Jacobian","page":"Home","title":"SymbolicCRN.Jacobian","text":"Jacobian(R, F)\nJacobian(R, F, vars)\n\n\nReturns the Jacobian matrix of a one-column matrix of polynomials F with respect to the generators of R indexed by vars. When vars is omitted all the generators of R are used.\n\nExamples\n\njulia> using Nemo\n\njulia> R, vars = PolynomialRing(ZZ, vcat([\"k$i\" for i in 1:5], [\"x$i\" for i in 1:4]));\n\njulia> F = [vars[1]*vars[2]*vars[6]-vars[8]; vars[3]*vars[9]+2*vars[7]]\n[k1*k2*x1-x3]\n[ k3*x4+2*x2]\n\njulia> Jacobian(R, F, 6:9)\n[k1*k2  0  -1   0]\n[    0  2   0  k3]\n\njulia> Jacobian(R, F)\n[k2*x1  k1*x1   0  0  0  k1*k2  0  -1   0]\n[    0      0  x4  0  0      0  2   0  k3]\n\n\n\n\n\n","category":"function"},{"location":"#SymbolicCRN.Jacobian_cp-Tuple{AbstractAlgebra.MatElem, AbstractAlgebra.MatElem, AbstractMatrix, Any, Any}","page":"Home","title":"SymbolicCRN.Jacobian_cp","text":"Jacobian_cp(N, Y, E, ls, hs)\n\n\nReturns Nemo's MatElem paramatrising the Jacobian of the dynamical system associated to a biochemical reaction network. We use \"convex parameters\", see\n\nrn = @reaction_network begin\n    k1,  X2 → X1\n    k2,  X1 → X2\nend k1 k2\n\nN = netstoichmat(rn)\nY = substoichmat(rn)\n\nE = raysof(cone_positivenullspace(N))\nW = conservationlaws(N)\n\n\n\n\n\n","category":"method"},{"location":"#SymbolicCRN.Newtonpolytope-Tuple{PolyPolyt}","page":"Home","title":"SymbolicCRN.Newtonpolytope","text":"Newtonpolytope(pp)\n\n\nReturns the Newton polytope of a PolyPolyt.\n\n\n\n\n\n","category":"method"},{"location":"#SymbolicCRN.coeff_charpoly-Tuple{AbstractAlgebra.MatElem, Any}","page":"Home","title":"SymbolicCRN.coeff_charpoly","text":"coeff_charpoly(M, i)\n\n\nReturns the i-th coefficient of the characteristic polynomial of M.\n\n\n\n\n\n","category":"method"},{"location":"#SymbolicCRN.cone_positivenullspace-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T<:Integer","page":"Home","title":"SymbolicCRN.cone_positivenullspace","text":"cone_positivenullspace(N)\n\n\nReturn the cone (Polymake big object) intersection of the nonnegative orthant and the nullspace of N.\n\n\n\n\n\n","category":"method"},{"location":"#SymbolicCRN.cone_positiveorthant-Tuple{Any}","page":"Home","title":"SymbolicCRN.cone_positiveorthant","text":"cone_positiveorthant(n)\n\n\nReturn the cone (Polymake big object) corresponding to the nonnegative orthant of R^n.\n\n\n\n\n\n","category":"method"},{"location":"#SymbolicCRN.cone_vectorspace-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T<:Integer","page":"Home","title":"SymbolicCRN.cone_vectorspace","text":"Return the cone (Polymake big object) corresponding to vector space generated by the columns of M.\n\n\n\n\n\n","category":"method"},{"location":"#SymbolicCRN.diagonal-Tuple{Any, AbstractVector}","page":"Home","title":"SymbolicCRN.diagonal","text":"diagonal(R, V)\n\n\nGiven a Julia vector V of entries, construct the corresponding AbstractAlgebra.jl diagonal matrix over the given ring R, assuming all the entries can be coerced into R.\n\n\n\n\n\n","category":"method"},{"location":"#SymbolicCRN.dissect-Tuple{AbstractAlgebra.MPolyElem}","page":"Home","title":"SymbolicCRN.dissect","text":"dissect(p)\n\n\nIterator for the coefficients and exponent vectors of the given polynomial.\n\n\n\n\n\n","category":"method"},{"location":"#SymbolicCRN.integermultiple","page":"Home","title":"SymbolicCRN.integermultiple","text":"Given an array of rational numbers A, returns a multiple λA whose entries are all integers, where λ=abs(lcm(denominator.(A))) is the minimal integer with this property.\n\n\n\n\n\n","category":"function"},{"location":"#SymbolicCRN.save_polypolyt-Tuple{AbstractString, PolyPolyt}","page":"Home","title":"SymbolicCRN.save_polypolyt","text":"save_polypolyt(name, pp)\n\n\nSave vertices of pp::PolyPolyt in file name * ver_sufix and ver-to-pt map in name * map_sufix\n\n\n\n\n\n","category":"method"},{"location":"#SymbolicCRN.vertex_index-Tuple{PolyPolyt, Int64}","page":"Home","title":"SymbolicCRN.vertex_index","text":"vertex_index(pp, i)\n\n\nGiven a vertex i of a PolyPolyt, returns the position of i in ver-to-pt map. That is, vertex_point_map(pp)[vertex_index(pp, i)] == i. Or more interestingly,\n\nverticesof(Newtonpolytope(pp))[:, vertex_index(pp, i)] == collect(exponent_vectors(pp.p))[:,i]\n\n\n\n\n\n","category":"method"},{"location":"#SymbolicCRN.vertex_point_map-Tuple{PolyPolyt}","page":"Home","title":"SymbolicCRN.vertex_point_map","text":"vertex_point_map(pp)\n\n\nReturns the ver-to-pt map of a PolyPolyt.\n\n\n\n\n\n","category":"method"}]
}
